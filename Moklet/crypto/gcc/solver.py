from Crypto.Util.number import inverse, long_to_bytes
from math import gcd

# Given values
N1 = 10049543485505850508453356053265438853308296173166108775916877881071950130183292805362209716865046538603083279644088293763050768198766922188266819814710113
N2 = 5798603592389674105033839478718198582684167510284961310781960181314341271145985476286515243696364039263808413017408173390783882307586600610324545213329859
e = 65537
c1 = 5322681941268357406404503954416265777496784739007266579812813618547002347095004870705631673696338401160537602291253514355749194760802399020817938522335428
c2 = 1550722608254682294165587937171395060673321041528667580966538308961360737033585485196197207315814122695037393462554035560367315109544387874231645453593313

# Compute gcd of N1 and N2
q = gcd(N1, N2)

# Compute p and r
p = N1 // q
r = N2 // q

# Compute phi(N1) and phi(N2)
phi_N1 = (p - 1) * (q - 1)
phi_N2 = (q - 1) * (r - 1)

# Compute d (the private exponent)
d1 = inverse(e, phi_N1)
d2 = inverse(e, phi_N2)

# Decrypt c1 and c2 to find m
m1 = pow(c1, d1, N1)
m2 = pow(c2, d2, N2)

# Convert the plaintext back to bytes
message1 = long_to_bytes(m1)
message2 = long_to_bytes(m2)

print(f"Message 1: {message1}")
print(f"Message 2: {message2}")
